use packed_simd::u16x32;

use std::cmp::min;

const RAW_INPUT: &str = include_str!("../../inputs/day03.txt");

pub fn day03() -> (usize, u16) {
    let input: Vec<_> = parse_input(RAW_INPUT).collect();

    (part1(&input), part2(&input))
}

pub fn part1(claims: &[Claim]) -> usize {
    let cloth_masks = cloth_masks();

    let mut cloth = [0; 1024 * 1024];

    for &Claim { left, top, width, height, .. } in claims {
        for y in top..top + height {
            for x in (left..left + width).step_by(32) {
                let start_idx = y as usize * 1024 + x as usize;
                let mask = cloth_masks[min(31, left + width - x - 1) as usize];
                let values = u16x32::from_slice_unaligned(&cloth[start_idx..]);
                (values + mask).write_to_slice_unaligned(&mut cloth[start_idx..]);
            }
        }
    }

    cloth.iter()
        .filter(|&&c| c >= 2)
        .count()
}

pub fn part2(claims: &[Claim]) -> u16 {
    let cloth_masks = cloth_masks();

    let mut cloth = [0; 1024 * 1024];

    for &Claim { left, top, width, height, .. } in claims {
        for y in top..top + height {
            for x in (left..left + width).step_by(32) {
                let start_idx = y as usize * 1024 + x as usize;
                let mask = cloth_masks[min(31, left + width - x - 1) as usize];
                let values = u16x32::from_slice_unaligned(&cloth[start_idx..]);
                (values + mask).write_to_slice_unaligned(&mut cloth[start_idx..]);
            }
        }
    }

    'outer: for &Claim { left, top, width, height, id, } in claims {
        for y in top..top + height {
            for x in left..left + width {
                if cloth[y as usize * 1024 + x as usize] > 1 {
                    continue 'outer;
                }
            }
        }
        return id;
    }

    panic!("No solution")
}

pub fn parse_input(input: &'static str) -> impl Iterator<Item = Claim> {
    input.lines().map(|line| {
        let mut splitted = line.split('@');
        let id = splitted.next().expect("missing id")[1..].trim();
        let raw_claim = splitted.next().expect("missing claim");

        let mut splitted = raw_claim.split(':');
        let mut pos = splitted.next().expect("missing pos").trim().split(',');
        let mut size = splitted.next().expect("missing size").trim().split('x');

        Claim {
            id: id.parse().expect("invalid ID"),
            left: pos.next().expect("missing left").parse().expect("invalid left"),
            top: pos.next().expect("missing top").parse().expect("invalid top"),
            width: size.next().expect("missing width").parse().expect("invalid width"),
            height: size.next().expect("missing height").parse().expect("invalid height"),
        }
    })
}

#[derive(Debug)]
pub struct Claim {
    id: u16,
    left: u16,
    top: u16,
    width: u16,
    height: u16,
}

fn cloth_masks() -> Vec<u16x32> {
    (0..32)
        .map(|stop| {
            let mut slice = [0; 32];
            for i in 0..stop + 1 { slice[i] = 1 }
            u16x32::from_slice_unaligned(&slice)
        })
        .collect()
    // [
    //     u16x32::new(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0),
    //     u16x32::new(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
    // ];

}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn p1() {
        let input: Vec<_> = parse_input(RAW_INPUT).collect();

        assert_eq!(part1(&input), 110891);
    }

    #[test]
    fn p2() {
        let input: Vec<_> = parse_input(RAW_INPUT).collect();

        assert_eq!(part2(&input), 297);
    }
}
